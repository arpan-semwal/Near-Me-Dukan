import Foundation
import PhonePePayment
import UIKit

class PPEventEmitter {

  public static var sharedInstance = PPEventEmitter()

  // ReactNativeEventEmitter is instantiated by React Native with the bridge.
  private static var eventEmitter: PhonePePaymentSDK!

  private init() {}

  // When React Native instantiates the emitter it is registered here.
  func registerEventEmitter(eventEmitter: PhonePePaymentSDK) {
    PPEventEmitter.eventEmitter = eventEmitter
  }

  func dispatch(name: String, body: Any?) {
    PPEventEmitter.eventEmitter.sendEvent(withName: name, body: body)
  }

  /// All Events which must be support by React Native.
  lazy var allEvents: [String] = {
    var allEventNames: [String] = ["notifyIfNotInstalled",
                                   "notifyIfPhonePeInstalled"]
    return allEventNames
  }()

}

public enum PPPaymentErrorCode : String {
  case appIdMissing
  case noRootVC
  case noSelf
  case unknown
  case failure
  case interupted
  case noAppIDFound
  case invalidEnvironment
  case noRequestBody
  case noChecksum
}

fileprivate enum SDKEnvironment: String {
    
    case sandbox = "SANDBOX"
    case prod = "PRODUCTION"
    
    var environment: PhonePePayment.Environment {
        switch self {
        case .sandbox:
            return PhonePePayment.Environment.sandbox
        case .prod:
            return PhonePePayment.Environment.production
        }
    }
}

fileprivate enum PPTransactionStatus {
    
    private enum PPStrings {
        // Transaction Result Keys
        static let status = "status"
        static let error = "error"
        
        // Transaction Status
        static let SUCCESS = "SUCCESS"
        static let FAILURE = "FAILURE"
        static let INTERUPTED = "INTERUPTED"
    }
    
    case success
    case failure(String)
    case interupted(String)
    
    var dictionary: [String: String] {
        var dict: [String: String] = [:]
        switch self {
        case .success:
            dict[PPStrings.status] = PPStrings.SUCCESS
        case .failure(let string):
            dict[PPStrings.status] = PPStrings.FAILURE
            dict[PPStrings.error] = string
        case .interupted(let string):
            dict[PPStrings.status] = PPStrings.INTERUPTED
            dict[PPStrings.error] = string
        }
        return dict
    }
}


@objc(PhonePePaymentSDK)
public class PhonePePaymentSDK: NSObject {
    
    var errorCode: PPPaymentErrorCode = .unknown
    
    // Transcation Requisites....
    private var sdkEnvironment: PhonePePayment.Environment = PhonePePayment.Environment.production
    private var enableLogging: Bool = false
    private var appId: String?
    
    var viewController: UIViewController?
    
    private enum APIEndpoint {
        static let pg_v1_pay = "/pg/v1/pay"
    }

    override init() {
        super.init()
        DispatchQueue.main.async {
            self.viewController = UIApplication.shared.windows.first?.rootViewController
        }
        
        PPEventEmitter.sharedInstance.registerEventEmitter(eventEmitter: self)
        // add observer for handling deeplink
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(handleOnOpen),
                                               name: NSNotification.Name("ApplicationOpenURLNotification"),
                                               object: nil)
    }
    
    @objc(init:merchantId:appId:enableLogging:withResolver:withRejecter:)
    func `init`(_ environment: String,
                 merchantId: String,
                 appId: String,
                 enableLogging: Bool,
                 withResolver resolve: @escaping RCTPromiseResolveBlock,
                 withRejecter reject: @escaping RCTPromiseRejectBlock) {
        self.enableLogging = enableLogging
        self.appId = appId
        
        guard let sdkEnv = SDKEnvironment(rawValue: environment) else {
            reject(PPPaymentErrorCode.invalidEnvironment.rawValue, "Invalid Environment: [\(environment)], Please provide a valid environment", nil)
            return
        }
        self.sdkEnvironment = sdkEnv.environment
        resolve(true)
    }
    
    @objc
    private func handleOnOpen(_ notification: Notification) {
        guard let userInfo = notification.userInfo else {
            return
        }
        
        if let url = userInfo["openUrl"] as? URL {
            _ = PPPayment.checkDeeplink(url)
        }
    }
        
    @objc(startTransaction:checksum:packageName:appSchema:withResolver:withRejecter:)
    func startTransaction(body : String,
                          checksum: String,
                          packageName: String,
                          appSchema:String,
                          withResolver resolve: @escaping RCTPromiseResolveBlock,
                          withRejecter reject: @escaping RCTPromiseRejectBlock) {
        
        guard let rootVC = self.viewController else {
            reject(PPPaymentErrorCode.noRootVC.rawValue, "Root VC not found", nil)
            return
        }
        
        guard !body.isEmpty else {
            reject(PPPaymentErrorCode.noRequestBody.rawValue, "Request body not found", nil)
            return
        }
        
        guard !checksum.isEmpty else {
            reject(PPPaymentErrorCode.noChecksum.rawValue, "Checksum not found", nil)
            return
        }
        
        let payment = PPPayment(environment: self.sdkEnvironment, enableLogging: enableLogging, appId: self.appId)
        payment.setAdditionalInfo(sdkType: PhonePePayment.SDKType.react_native)
        let request = PPTransactionRequest(body: body,
                                           apiEndPoint: APIEndpoint.pg_v1_pay,
                                           checksum: checksum,
                                           headers: [:],
                                           appSchema: appSchema)
        payment.startPG(transactionRequest: request, on: rootVC, animated: true) { [weak self] (request, state) in
            
            guard let self else {
                reject(PPPaymentErrorCode.noSelf.rawValue, "Root VC not found", nil)
                return
            }
            
            switch state {
            case .success:
                resolve(PPTransactionStatus.success.dictionary)
            case .failure(let error):
                resolve(PPTransactionStatus.failure(error.localizedDescription).dictionary)
            case .interrupted(let error):
                resolve(PPTransactionStatus.interupted(error.localizedDescription).dictionary)
            @unknown default:
                reject(PPPaymentErrorCode.unknown.rawValue, "Unknown Transaction status received", nil)
            }
        }
    }
    
    @objc(isPhonePeInstalled:withRejecter:)
    func isPhonePeInstalled(withResolver resolve: @escaping RCTPromiseResolveBlock,
                            withRejecter reject: @escaping RCTPromiseRejectBlock) {
        resolve(PPPayment.isPhonePeInstalled())
    }
    
    @objc(isPaytmAppInstalled:withRejecter:)
    func isPaytmAppInstalled(withResolver resolve: @escaping RCTPromiseResolveBlock,
                             withRejecter reject: @escaping RCTPromiseRejectBlock) {
        resolve(PPPayment.isPaytmAppPresent())
    }
    
    @objc(isGPayAppInstalled:withRejecter:)
    func isGPayAppInstalled(withResolver resolve: @escaping RCTPromiseResolveBlock,
                            withRejecter reject: @escaping RCTPromiseRejectBlock) {
        resolve(PPPayment.isGPayAppPresent())
    }
    
    func sendEvent(withName name: String, body: Any?) {
        // do nothing
        // later will be updated with event emission.
    }
  }

